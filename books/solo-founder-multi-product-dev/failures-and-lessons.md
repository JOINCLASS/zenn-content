---
title: "失敗と教訓 — 実際にやらかしたこと"
---

## 成功事例だけでは学べない

ここまでの章では、技術選定やアーキテクチャ設計の「うまくいった」部分を中心に解説してきました。しかし、実際の運用では失敗の方が多い。そして、失敗からの学びの方が価値が高い。

この章では、5プロダクトの運用で実際にやらかした失敗を4つ、具体的に共有します。それぞれの失敗がなぜ起きたのか、どのような影響があったのか、そしてどう対処したのかを正直に記録します。

## 失敗1: Next.jsのバージョンが揃わなくなった

### 何が起きたか

FocalizeはNext.js 14で構築し、ShareTokuは後からNext.js 16で始めました。Skill Tracker LPは15系です。結果として、3つのプロダクトで3つの異なるNext.jsバージョンが共存しています。

Reactのバージョンも、Focalizeは18系、ShareTokuは19系という状態です。

### なぜこうなったか

原因は明確です。**新しいプロダクトを始める際に、最新バージョンのNext.jsを使いたくなった**からです。ShareTokuの開発を始めた時点でNext.js 16が出ていたので、「せっかくなら最新を」と16で始めました。Skill Trackerも同様に、その時点の最新である15系で開始しました。

一方、Focalizeは14系のまま。機能開発が優先され、フレームワークのアップグレードは「いつかやる」リストに入ったまま放置されています。

### どんな問題が生じているか

**知識の混乱。** App Routerの細かい挙動がバージョンで異なります。FocalizeではServer Actionsの書き方がShareTokuと微妙に違う。あるプロダクトで学んだパターンが、別のプロダクトではコンパイルエラーになる。

```typescript
// Next.js 14系 (Focalize)
// Server Actionの定義方法
'use server'

export async function createDeal(formData: FormData) {
  // ...
}

// Next.js 16系 (ShareToku)
// 同じServer Actionでも、細かいAPI差異がある
// useActionStateのシグネチャが変わっている等
```

**依存関係の不一致。** あるライブラリがReact 19を要求し、Focalizeでは使えないケースが出てきました。逆に、FocalizeでReact 18向けに書いたコードをShareTokuにコピーすると、React 19のStrict Modeで警告が出ることもあります。

**アップグレードの負債が雪だるま式に増加。** Focalizeの14→15→16へのアップグレードは、時間が経つほど難しくなります。14→15の破壊的変更と15→16の破壊的変更を一度に対処する必要があり、段階的な移行が困難です。

### 教訓

**新しいプロダクトを始める際は、既存プロダクトとメジャーバージョンを揃えるか、既存プロダクトのアップグレードを先に済ませてから着手すべき。**

「最新バージョンを使いたい」という欲求は分かります。しかし、1人で複数プロダクトを運用する場合、バージョンの統一の方がはるかに重要です。バージョンが揃っていれば、あるプロダクトで書いたコードを別のプロダクトにそのまま適用できます。この「移植可能性」の価値は、新機能へのアクセスよりも大きい。

### 現在の対処

Focalizeの14→16アップグレードを計画中ですが、Stripeの統合やnext-authの設定など、影響範囲が広いため慎重に進めています。四半期の「負債返済週」を2回分使って段階的にアップグレードする予定です。

## 失敗2: 状態管理ライブラリの不統一（Provider vs Riverpod）

### 何が起きたか

FlutterプロダクトでMochiQはProvider、元気ボタンはRiverpodを使っています。元気ボタンを後から開発した際に「Riverpodの方が型安全でテスタビリティが高い」と判断して切り替えました。

### なぜこうなったか

MochiQを開発した時点ではProviderが主流でした。元気ボタンを開発する頃にはRiverpodが成熟し、コミュニティでも「新規プロジェクトはRiverpodを使うべき」という声が大きくなっていました。

技術的には正しい判断です。Riverpodは確かにProviderより優れている点が多い。

- **型安全性**: プロバイダの依存関係がコンパイル時に検証される
- **テスタビリティ**: プロバイダのオーバーライドが容易
- **コード生成**: `@riverpod`アノテーションで定型コードを削減

しかし、「技術的に正しい」ことと「マルチプロダクト運用で最適」なことは別です。

### どんな問題が生じているか

**コードの移植が困難。** MochiQで書いた状態管理のロジックを元気ボタンに移植する場合、ProviderのパターンをRiverpodのパターンに書き換える必要があります。

```dart
// MochiQ (Provider)
class QuizNotifier extends ChangeNotifier {
  List<Quiz> _quizzes = [];
  List<Quiz> get quizzes => _quizzes;

  Future<void> loadQuizzes() async {
    _quizzes = await _repository.getAll();
    notifyListeners();
  }
}

// 元気ボタン (Riverpod)
@riverpod
class CheckInNotifier extends _$CheckInNotifier {
  @override
  Future<List<CheckIn>> build() async {
    return await ref.watch(checkInRepositoryProvider).getAll();
  }
}
```

概念的には同じことをしていますが、コードの構造が全く異なります。片方で学んだパターンが直接活かせません。

**認知的コスト。** ProviderのBuildContextベースのアクセスと、Riverpodのrefベースのアクセスで、頭の切り替えが必要です。Next.jsのTypeScriptとFlutterのDartの切り替えよりも、同じDart言語内での状態管理パターンの切り替えの方が混乱しやすい。

### 教訓

**クロスプラットフォームプロダクトの設計パターンは早い段階で標準を決め、新規プロダクトでも踏襲すべき。「より良い選択肢がある」としても、統一の価値は過小評価しない方がいい。**

これは第3章の技術選定の話と同根の問題です。「最適な技術を選ぶ」ことと「統一された技術で運用する」ことは、しばしば矛盾します。1人でマルチプロダクトを運用する場合、統一の方が総合的なコストは低い。

### 現在の対処

MochiQの次のメジャーアップデート時にProviderからRiverpodに移行する計画ですが、優先度は低いです。現状動いているものを「統一のため」だけに書き換えるリスクは無視できません。新規のFlutterプロダクトがあれば、Riverpodで統一します。

## 失敗3: モニタリング導入の遅れ

### 何が起きたか

初期段階ではプロダクトの機能開発を優先し、モニタリング・アナリティクスを後回しにしました。FocalizeでUmamiによるアクセス解析を導入するまで、ユーザーの行動をほとんど把握できていませんでした。

Flutterアプリでは、Firebase Analyticsを後からMochiQに追加し、元気ボタンにも同様に導入しましたが、初期のユーザー行動データは完全に失われています。

### なぜこうなったか

「まずは機能を作って、ユーザーが使い始めてからデータを取ろう」という判断です。リソースが限られている中で、目に見える機能開発を優先したい気持ちは自然です。

しかしこの判断は間違いでした。

### どんな問題が生じたか

**初期ユーザーの行動が不明。** 最初のユーザーがどのページを見て、どこで離脱したのかが一切分かりません。初期のコンバージョンファネルを改善するための数値がゼロです。

**仮説の検証ができなかった。** 「このLPの構成なら離脱率は低いはず」という仮説を立てても、数値で検証できない。「最近ユーザーが増えている気がする」という感覚でしか判断できない状態は、意思決定の質を大きく下げます。

**後からの導入コスト。** アナリティクスを後から追加する場合、既存のコンポーネントにイベントトラッキングのコードを追加する作業が必要です。最初から入れておけば機能実装と同時に自然とトラッキングコードも書いていたはずです。

### 教訓

**アナリティクスは機能開発と同じ優先度で初日から入れるべき。最小限でもページビューとユーザー数だけは計測しておく。データがなければ改善の判断ができない。**

実装コストは最小限です。Webなら`<script>`タグ1つ、FlutterならFirebase Analyticsのプラグインを追加するだけ。カスタムイベントは後から追加できるが、基本的なページビューのデータは初日から取り始めるべきです。

### 現在の対処

現在は全プロダクトでアナリティクスを導入済みです。新しいプロダクトを始める際の初期テンプレートにアナリティクスの設定を含めることで、「入れ忘れ」を構造的に防いでいます。

## 失敗4: 初期の過剰な機能開発

### 何が起きたか

Focalizeの初期バージョンで、「営業自動化」という名前に引っ張られて、リードスコアリング、メールテンプレート管理、案件の予測分析など、多くの機能を一度に開発しようとしました。

結果、MVPのリリースが2か月以上遅れました。

### なぜこうなったか

「競合と差別化するにはこの機能が必要」「プレゼンでこの機能を見せたい」「せっかくなら完成度の高い状態でリリースしたい」。いずれも分かる気持ちです。しかし、1人開発の現実を無視した判断でした。

### どんな問題が生じたか

**リリースの遅延。** 2か月の遅延は、2か月分のユーザーフィードバックを失ったことを意味します。MVPで得られたはずの「実際のユーザーが何を求めているか」というデータが2か月遅れになりました。

**使われない機能の山。** リリース後に分かったのは、ユーザーが最も使う機能は「商談のパイプライン表示」と「フォローアップリマインダー」の2つだけだったことです。リードスコアリングや予測分析は、ほとんど使われませんでした。

**メンテナンスコストの増大。** 使われない機能もコードベースに存在する限り、テストの対象になり、ライブラリのアップデート時に互換性を確認する必要があります。「存在するだけでコストが発生する」状態です。

### 教訓

**MVPは本当に「Minimum」であるべき。1人開発のMVPは、自分が思う「最小限」のさらに半分で十分。**

元気ボタンの成功はこの教訓の実践例です。ボタン1つ、プッシュ通知1つ。それ以上の機能を最初から作ろうとしなかった。結果、ユーザーの反応を早期に得られ、本当に必要な機能（履歴ダッシュボード、リマインダー設定）を後から追加できました。

### 現在の対処

新しいプロダクトを始める際は、以下のルールを設けています。

1. **MVPの機能は3つまで**: コア機能を3つに絞り、それ以外は「v2 candidates」リストに入れる
2. **2週間でリリース可能な範囲にする**: 2週間で作れない量は、MVPとして過剰
3. **ユーザーの声を聞いてから追加する**: v2 candidatesリストの機能は、ユーザーから要望があったものだけ実装する

## 4つの失敗に共通するパターン

振り返ると、4つの失敗には共通するパターンがあります。

**「技術的に正しい」選択が「運用的に最適」とは限らない。**

- 最新のNext.jsバージョンを使うのは技術的に正しい。でも統一の方が運用コストは低い
- Riverpodの方がProviderより優れている。でも統一の方が移植性は高い
- 機能が多い方がユーザー価値は高いように見える。でもMVPはミニマムであるべき

**「後でやる」は「やらない」と同義。**

- フレームワークのアップグレードを「後で」やろうとして、負債が雪だるま式に増加
- モニタリングを「後で」入れようとして、初期データを完全に失った

1人で5プロダクトを運用する場合、「後で」のキャパシティはほぼゼロです。やるなら今やる。今やれないなら、それは「やらない」という意思決定として明示的に記録する。

## 失敗から構築したチェックリスト

これらの失敗を繰り返さないために、新しいプロダクトを始める際のチェックリストを作成しました。

```
新規プロダクト開始チェックリスト:

□ フレームワークのバージョンは既存プロダクトと揃っているか
□ 状態管理/アーキテクチャパターンは標準に従っているか
□ アナリティクスは初日から組み込まれているか
□ MVPの機能は3つ以内に絞れているか
□ 2週間以内にリリースできるスコープか
□ CI/CDパイプラインは初日から設定されているか
□ セキュリティヘッダーのテンプレートは適用されているか
□ .env.example が用意されているか
```

完璧ではありませんが、「同じ失敗を繰り返さない」ための最低限のガードレールとして機能しています。

次の章で、本書の内容をまとめます。
